"""
Script: análise_pib_percapita.py
Baseado no PDF enviado: "PCG - Relação entre desenvolvimento econômico e geografia"
O script carrega dois datasets (World Bank GDP per capita e countries.csv do Google), limpa,
integra, gera os 10 maiores/menores PIB per capita (gráficos) e cria um mapa interativo com folium.

Como usar:
- Coloque os arquivos CSV na mesma pasta do script e ajuste os nomes de arquivo abaixo se necessário.
- Execute em um ambiente com pandas, matplotlib e folium instalados.
  Ex: pip install pandas matplotlib folium

Saídas geradas:
- top10_maiores.png
- top10_menores.png
- mapa_pib_percapita.html

Autor: Gerado por ChatGPT (baseado no PDF do usuário)
"""

import os
import pandas as pd
import matplotlib.pyplot as plt
import folium
from folium.plugins import MarkerCluster

# ----------------------------
# Configurações de arquivo
# ----------------------------
# Ajuste estes nomes caso seus CSVs tenham nomes diferentes
WORLD_BANK_CSV = 'API_NY.GDP.PCAP.CD_DS2_en_csv_v2_184.csv'
COUNTRIES_CSV = 'countries.csv'
OUTPUT_DIR = 'output'
os.makedirs(OUTPUT_DIR, exist_ok=True)

# ----------------------------
# Funções utilitárias
# ----------------------------

def carregar_world_bank(path):
    """Carrega e trata o CSV do World Bank com PIB per capita.
    O arquivo original do World Bank possui metadados nas primeiras linhas em algumas versões;
    este código tenta detectar e pular linhas iniciais que não fazem parte do cabeçalho.
    Espera colunas: 'country' (sigla), 'name' (nome) e 'PIB' ou valores por ano.
    """
    # Tentar leitura direta
    try:
        df = pd.read_csv(path)
    except Exception as e:
        raise RuntimeError(f'Erro ao ler {path}: {e}')

    # Normalizar nomes de colunas para facilitar
    df.columns = [c.strip() for c in df.columns]

    # Possíveis formatos:
    # 1) Arquivo já pré-processado (contem colunas: country, name, PIB)
    # 2) Arquivo completo do World Bank (com anos como colunas). Buscaremos o último ano disponível.

    if 'PIB' in df.columns:
        df = df.rename(columns={'PIB': 'gdp_percapita'})
        df['gdp_percapita'] = pd.to_numeric(df['gdp_percapita'], errors='coerce')
        return df[['country', 'name', 'gdp_percapita']]

    # Caso o arquivo tenha colunas de ano (ex: '1960', '1970', ..., '2022')
    # Selecionar a última coluna numérica como valor mais recente do PIB per capita
    year_cols = [c for c in df.columns if c.isdigit()]
    if len(year_cols) > 0:
        latest_year = max(int(c) for c in year_cols)
        latest_col = str(latest_year)
        df = df.rename(columns={'country': 'country', 'Country Code': 'country_code'})
        # Algumas versões usam 'Country Name' como nome
        name_col = None
        for candidate in ['name', 'Country Name', 'Country']:
            if candidate in df.columns:
                name_col = candidate
                break
        if name_col is None:
            df['name'] = df['country'] if 'country' in df.columns else df.iloc[:,0]
            name_col = 'name'

        result = pd.DataFrame({
            'country': df['country'] if 'country' in df.columns else df.get('Country Code', df.index),
            'name': df[name_col],
            'gdp_percapita': pd.to_numeric(df[latest_col], errors='coerce')
        })
        return result

    # Fallback: tentar encontrar qualquer coluna com valores numéricos que pareçam PIB
    numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
    if numeric_cols:
        col = numeric_cols[-1]
        result = pd.DataFrame({
            'country': df['country'] if 'country' in df.columns else df.index,
            'name': df['name'] if 'name' in df.columns else df.index,
            'gdp_percapita': pd.to_numeric(df[col], errors='coerce')
        })
        return result

    raise RuntimeError('Formato do CSV do World Bank não reconhecido. Verifique o arquivo.')


def carregar_countries(path):
    """Carrega o CSV de countries (Google public data). Espera colunas: 'country' (sigla), 'name', 'latitude', 'longitude'."""
    df = pd.read_csv(path)
    df.columns = [c.strip() for c in df.columns]

    # Normalizar nomes de coluna
    colmap = {}
    for c in df.columns:
        lc = c.lower()
        if 'iso' in lc or lc == 'country' or lc == 'alpha2' or lc == 'alpha-2' or 'code' in lc:
            colmap[c] = 'country'
        if 'name' == lc or 'country name' in lc:
            colmap[c] = 'name'
        if 'lat' in lc:
            colmap[c] = 'latitude'
        if 'long' in lc or 'lon' in lc:
            colmap[c] = 'longitude'

    df = df.rename(columns=colmap)

    for req in ['country', 'name', 'latitude', 'longitude']:
        if req not in df.columns:
            # Nem sempre haverá latitude/longitude; nesse caso deixamos sem coordenadas
            if req in ['latitude', 'longitude']:
                df[req] = pd.NA
            else:
                raise RuntimeError(f'Coluna obrigatória "{req}" não encontrada em {path}')

    df['latitude'] = pd.to_numeric(df['latitude'], errors='coerce')
    df['longitude'] = pd.to_numeric(df['longitude'], errors='coerce')

    return df[['country', 'name', 'latitude', 'longitude']]


# ----------------------------
# Execução principal
# ----------------------------

def main():
    print('Carregando datasets...')
    wb = carregar_world_bank(WORLD_BANK_CSV)
    countries = carregar_countries(COUNTRIES_CSV)

    # Padronizar códigos para merge (usar maiúsculas)
    wb['country'] = wb['country'].astype(str).str.upper().str.strip()
    countries['country'] = countries['country'].astype(str).str.upper().str.strip()

    # Merge
    merged = pd.merge(wb, countries, on='country', how='left', suffixes=('_wb', '_geo'))

    # Caso existam nomes diferentes, priorizar o nome do World Bank, senão usar o do countries
    merged['country_name'] = merged['name_wb'].fillna(merged['name_geo'])
    merged['gdp_percapita'] = pd.to_numeric(merged['gdp_percapita'], errors='coerce')

    # Remover registros sem gdp_percapita
    merged_clean = merged.dropna(subset=['gdp_percapita']).copy()

    print(f'Total de países com PIB per capita: {len(merged_clean)}')

    # Top 10 maiores
    top10_maiores = merged_clean.nlargest(10, 'gdp_percapita')[['country', 'country_name', 'gdp_percapita']]
    top10_menores = merged_clean.nsmallest(10, 'gdp_percapita')[['country', 'country_name', 'gdp_percapita']]

    # Gráficos
    print('Gerando gráficos...')
    plt.rcParams.update({'figure.figsize': (10,6)})

    fig1 = plt.figure()
    plt.barh(top10_maiores['country_name'][::-1], top10_maiores['gdp_percapita'][::-1])
    plt.title('Top 10 maiores PIB per capita')
    plt.xlabel('PIB per capita (USD)')
    plt.tight_layout()
    path1 = os.path.join(OUTPUT_DIR, 'top10_maiores.png')
    plt.savefig(path1)
    plt.close(fig1)

    fig2 = plt.figure()
    plt.barh(top10_menores['country_name'][::-1], top10_menores['gdp_percapita'][::-1])
    plt.title('Top 10 menores PIB per capita')
    plt.xlabel('PIB per capita (USD)')
    plt.tight_layout()
    path2 = os.path.join(OUTPUT_DIR, 'top10_menores.png')
    plt.savefig(path2)
    plt.close(fig2)

    print('Gráficos salvos em:', path1, 'e', path2)

    # Mapa interativo com folium
    print('Criando mapa interativo...')
    # Centro do mapa: média das coordenadas disponíveis
    lat_mean = merged_clean['latitude'].dropna().mean() if merged_clean['latitude'].notna().any() else 0
    lon_mean = merged_clean['longitude'].dropna().mean() if merged_clean['longitude'].notna().any() else 0

    m = folium.Map(location=[lat_mean, lon_mean], zoom_start=2, tiles='CartoDB positron')

    marker_cluster = MarkerCluster().add_to(m)

    # Normalizar tamanho do marcador pelo PIB per capita (para exibição)
    gdp_min = merged_clean['gdp_percapita'].min()
    gdp_max = merged_clean['gdp_percapita'].max()
    def escala_radius(v):
        if pd.isna(v):
            return 3
        # escala linear entre 3 e 20
        if gdp_max == gdp_min:
            return 6
        return 3 + ( (v - gdp_min) / (gdp_max - gdp_min) ) * 17

    for _, row in merged_clean.iterrows():
        lat = row.get('latitude')
        lon = row.get('longitude')
        if pd.isna(lat) or pd.isna(lon):
            continue
        popup = folium.Popup(f"{row['country_name']} ({row['country']})<br>PIB per capita: {row['gdp_percapita']:,.2f}", max_width=300)
        folium.CircleMarker(
            location=[lat, lon],
            radius=escala_radius(row['gdp_percapita']),
            fill=True,
            fill_opacity=0.7,
            popup=popup
        ).add_to(marker_cluster)

    map_path = os.path.join(OUTPUT_DIR, 'mapa_pib_percapita.html')
    m.save(map_path)
    print('Mapa salvo em:', map_path)

    # Salvar CSV com dados mesclados e limpos
    cleaned_csv = os.path.join(OUTPUT_DIR, 'pib_percapita_merged_clean.csv')
    merged_clean.to_csv(cleaned_csv, index=False)
    print('CSV limpo salvo em:', cleaned_csv)

    print('\nProcesso concluído. Verifique a pasta output/ para os arquivos gerados.')


if __name__ == '__main__':
    main()
